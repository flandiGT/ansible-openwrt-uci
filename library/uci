#!/usr/bin/lua

--------------------------------------------------------------------------------
-- JSON stringlify and parse functions
-- downloaded from: https://gist.github.com/tylerneylon/59f4bcf316be525b30ab
--------------------------------------------------------------------------------
function createJson()
  local json = {}


  -- Internal functions.

  local function kind_of(obj)
    if type(obj) ~= 'table' then return type(obj) end
    local i = 1
    for _ in pairs(obj) do
      if obj[i] ~= nil then i = i + 1 else return 'table' end
    end
    if i == 1 then return 'table' else return 'array' end
  end

  local function escape_str(s)
    local in_char  = {'\\', '"', '/', '\b', '\f', '\n', '\r', '\t'}
    local out_char = {'\\', '"', '/',  'b',  'f',  'n',  'r',  't'}
    for i, c in ipairs(in_char) do
      s = s:gsub(c, '\\' .. out_char[i])
    end
    return s
  end

  -- Returns pos, did_find; there are two cases:
  -- 1. Delimiter found: pos = pos after leading space + delim; did_find = true.
  -- 2. Delimiter not found: pos = pos after leading space;     did_find = false.
  -- This throws an error if err_if_missing is true and the delim is not found.
  local function skip_delim(str, pos, delim, err_if_missing)
    pos = pos + #str:match('^%s*', pos)
    if str:sub(pos, pos) ~= delim then
      if err_if_missing then
        error('Expected ' .. delim .. ' near position ' .. pos)
      end
      return pos, false
    end
    return pos + 1, true
  end

  -- Expects the given pos to be the first character after the opening quote.
  -- Returns val, pos; the returned pos is after the closing quote character.
  local function parse_str_val(str, pos, val)
    val = val or ''
    local early_end_error = 'End of input found while parsing string.'
    if pos > #str then error(early_end_error) end
    local c = str:sub(pos, pos)
    if c == '"'  then return val, pos + 1 end
    if c ~= '\\' then return parse_str_val(str, pos + 1, val .. c) end
    -- We must have a \ character.
    local esc_map = {b = '\b', f = '\f', n = '\n', r = '\r', t = '\t'}
    local nextc = str:sub(pos + 1, pos + 1)
    if not nextc then error(early_end_error) end
    return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
  end

  -- Returns val, pos; the returned pos is after the number's final character.
  local function parse_num_val(str, pos)
    local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)
    local val = tonumber(num_str)
    if not val then error('Error parsing number at position ' .. pos .. '.') end
    return val, pos + #num_str
  end


  -- Public values and functions.

  function json.stringify(obj, as_key)
    local s = {}  -- We'll build the string as an array of strings to be concatenated.
    local kind = kind_of(obj)  -- This is 'array' if it's an array or type(obj) otherwise.
    if kind == 'array' then
      if as_key then error('Can\'t encode array as key.') end
      s[#s + 1] = '['
      for i, val in ipairs(obj) do
        if i > 1 then s[#s + 1] = ', ' end
        s[#s + 1] = json.stringify(val)
      end
      s[#s + 1] = ']'
    elseif kind == 'table' then
      if as_key then error('Can\'t encode table as key.') end
      s[#s + 1] = '{'
      for k, v in pairs(obj) do
        if #s > 1 then s[#s + 1] = ', ' end
        s[#s + 1] = json.stringify(k, true)
        s[#s + 1] = ':'
        s[#s + 1] = json.stringify(v)
      end
      s[#s + 1] = '}'
    elseif kind == 'string' then
      return '"' .. escape_str(obj) .. '"'
    elseif kind == 'number' then
      if as_key then return '"' .. tostring(obj) .. '"' end
      return tostring(obj)
    elseif kind == 'boolean' then
      return tostring(obj)
    elseif kind == 'nil' then
      return 'null'
    else
      error('Unjsonifiable type: ' .. kind .. '.')
    end
    return table.concat(s)
  end

  json.null = {}  -- This is a one-off table to represent the null value.

  function json.parse(str, pos, end_delim)
    pos = pos or 1
    if pos > #str then error('Reached unexpected end of input.') end
    local pos = pos + #str:match('^%s*', pos)  -- Skip whitespace.
    local first = str:sub(pos, pos)
    if first == '{' then  -- Parse an object.
      local obj, key, delim_found = {}, true, true
      pos = pos + 1
      while true do
        key, pos = json.parse(str, pos, '}')
        if key == nil then return obj, pos end
        if not delim_found then error('Comma missing between object items.') end
        pos = skip_delim(str, pos, ':', true)  -- true -> error if missing.
        obj[key], pos = json.parse(str, pos)
        pos, delim_found = skip_delim(str, pos, ',')
      end
    elseif first == '[' then  -- Parse an array.
      local arr, val, delim_found = {}, true, true
      pos = pos + 1
      while true do
        val, pos = json.parse(str, pos, ']')
        if val == nil then return arr, pos end
        if not delim_found then error('Comma missing between array items.') end
        arr[#arr + 1] = val
        pos, delim_found = skip_delim(str, pos, ',')
      end
    elseif first == '"' then  -- Parse a string.
      return parse_str_val(str, pos + 1)
    elseif first == '-' or first:match('%d') then  -- Parse a number.
      return parse_num_val(str, pos)
    elseif first == end_delim then  -- End of an object or array.
      return nil, pos + 1
    else  -- Parse true, false, or null.
      local literals = {['true'] = true, ['false'] = false, ['null'] = json.null}
      for lit_str, lit_val in pairs(literals) do
        local lit_end = pos + #lit_str - 1
        if str:sub(pos, lit_end) == lit_str then return lit_val, lit_end + 1 end
      end
      local pos_info_str = 'position ' .. pos .. ': ' .. str:sub(pos, pos + 10)
      error('Invalid json syntax starting at ' .. pos_info_str)
    end
  end

  return json
end
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


local uci  = require('uci').cursor()
local json = createJson()


function split(inputstr, sep)
  if sep == nil then
    sep = "%s"
  end
  local t={}
  local i=1
  for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
    t[i] = str
    i = i + 1
  end
  return t
end


function createAnsibleArgumentParser()
  local fs   = require('nixio.fs')
  local parser = {}

  function parser.parse(arguments)
    local argumentsLine = fs.readfile(arg[1])

    argumentsLine = string.gsub(argumentsLine, "\\", "")
    argumentsLine = string.gsub(argumentsLine, "\"", "")

    return split(argumentsLine, " ")
  end

  return parser
end


function createBashArgumentParser()
  local parser = {}

  function parser.parse(arguments)
    return arguments
  end

  return parser
end


function getArgumentParser()
  function string.starts(String,Start)
     return string.sub(String,1,string.len(Start))==Start
  end

  local parser
  if string.starts(arg[0], "/root/.ansible/tmp") then
    parser = createAnsibleArgumentParser()
  else
    parser = createBashArgumentParser()
  end

  return parser
end


function exitFailed(message)
  local failed = {
    failed = true,
    msg = message
  }
  print(json.stringify(failed))
  os.exit(1)
end


debug = function (object)
  print(json.stringify(object))
end


function exitChanged(message)
  local changed = {
    changed = true,
  }

  if message then
    changed["msg"] = message
    print(json.stringify(changed))
  else
    print(json.stringify(changed))
  end
  os.exit(0)
end


function exitUnchanged(message)
  local unchanged = {
    changed = false,
  }

  if message then
    unchanged["msg"] = message
    print(json.stringify(unchanged))
  else
    print(json.stringify(unchanged))
  end

  os.exit(0)
end


function tryToParseOptionalParameter(argumentLine, name)
  local find = name .. "="
  local length = string.len(find)
  local start_index = string.find(argumentLine, find)

  if not start_index then
    return nil
  end

  local last_index = string.find(argumentLine, " ", start_index)

  if not last_index then
    last_index = string.len(argumentLine)
  end

  return string.sub(argumentLine, start_index + length, last_index)
end


function parseOptionalParameter(arguments, name)
  local argumentValue

  for k, v in pairs(arguments) do
    if k > 0 then
      argumentValue = tryToParseOptionalParameter(v, name)
      if argumentValue then
        return argumentValue
      end
    end
  end

  return argumentValue
end


function parseMandatoryParameter(arguments, name)
  local parameter = parseOptionalParameter(arguments, name)

  if not parameter then
    exitFailed("mandatory argument or value '" .. name .. "' is missing")
  end

  return parameter
end


function getUciSection(config, sectionType)
  local section

  uci:foreach(config, sectionType, function(sectionObject) section = sectionObject end)

  return section
end


function getUciValue(config, section, option)
  local value

  if section then
    value = uci:get(config, section, option)
  else
    uci:foreach(config, config, function(sectionObject) value = sectionObject[option] end)
  end

  return value
end


function getSectionName(config, sectionType)
  local uciSection = getUciSection(config, sectionType)
  return uciSection[".name"]
end


function setUciValue(config, section, option, newValue)
  local oldValue = getUciValue(config, section, option)

  if oldValue and oldValue == newValue then
      exitUnchanged()
  else
    uci:set(config, section, option, newValue)
    uci:save(config)

    exitChanged()
  end
end


function setUciTypeValue(config, type, option, newValue)
  local section = getSectionName(config, type)
  setUciValue(config, section, option, newValue)
end


function Set (list)
  local set = {}
  for _, l in ipairs(list) do set[l] = true end
  return set
end


function size(list)
  if type(list.n) == "number" then return list.n end

  local max = 0
  for i, _ in pairs(list) do
    if type(i) == "number" and i > max then max = i end
  end

  return max
end


function areListsEqual(first, second)
  if size(first) ~= size(second) then
    return false
  end

  local firstAsSet = Set(first)

  for _, value in pairs(second) do
    if not firstAsSet[value] then
      return false
    end
  end

  return true
end


function setUciList(config, section, option, newValue)
  if not section then
    section = getSectionName(config, config)
  end

  local oldValue = getUciValue(config, section, option)

  if oldValue and areListsEqual(oldValue, newValue) then
    exitUnchanged()
  else
    uci:set(config, section, option, newValue)
    uci:save(config)

    exitChanged()
  end
end


function areEqual(firstValue, secondValue)
  local areEqual = true
  if firstValue then
    if secondValue then
      local newObjectType = type(secondValue)
      if newObjectType == type(firstValue) then
        if newObjectType == "table" then
          for k, v in pairs(secondValue) do
            if not areEqual(firstValue[k], v) then
              areEqual = false
              break
            end
          end
        else
          areEqual = firstValue == secondValue
        end
      else
        areEqual = false
      end
    else
      areEqual = false
    end
  else
    if not secondValue then
      areEqual = true
    else
      areEqual = false
    end
  end

  return areEqual
end


function setUciObject(config, section, newValue)
  local oldObject = uci:get(config, section)
  print(json.stringify(oldObject))

  if oldValue and areEqual(oldValue, newValue) then
    exitUnchanged()
  else
    uci:set(config, section, newValue)
    uci:save(config)

    exitChanged()
  end
end


local arguments = getArgumentParser().parse(arg)
local command = parseMandatoryParameter(arguments, "command")

if command == "get" then
  local config = parseMandatoryParameter(arguments, "config")
  local section = parseOptionalParameter(arguments, "section")
  local option = parseMandatoryParameter(arguments, "option")

  local value = getUciValue(config, section, option)

  exitUnchanged(value)
elseif command == "set" then
  local config = parseMandatoryParameter(arguments, "config")
  local option = parseMandatoryParameter(arguments, "option")
  local value = parseMandatoryParameter(arguments, "value")

  local section = parseOptionalParameter(arguments, "section")
  if section then
    setUciValue(config, section, option, value)
  else
    local type = parseMandatoryParameter(arguments, "type")
    setUciTypeValue(config, type, option, value)
  end
elseif command == "set_list" then
  local config = parseMandatoryParameter(arguments, "config")
  local section = parseOptionalParameter(arguments, "section")
  local option = parseMandatoryParameter(arguments, "option")
  local value = parseMandatoryParameter(arguments, "value")

  setUciList(config, section, option, split(value, ","))
elseif command == "set_object" then
  local config = parseMandatoryParameter(arguments, "config")
  local section = parseOptionalParameter(arguments, "section")
  local option = parseMandatoryParameter(arguments, "option")
  local value = parseMandatoryParameter(arguments, "value")

  setUciObject(config, section, option, value)
elseif command == "commit" then
  local config = parseMandatoryParameter(arguments, "config")
  uci:commit(config)

  exitChanged()
elseif command == "get_all" then
  local config = parseMandatoryParameter(arguments, "config")
  local values = uci:get_all(config)

  exitUnchanged(values)
else
  exitFailed("unsupported command '" .. command )
end
